
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BC SoftWear — Customer Price List</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Public multi-currency customer price list with VAT-inclusive display and daily FX conversion.">
  styles.css
</head>
<body>
  <header>
    <h1>BC SoftWear — Customer Price List</h1>

    <div class="controls" role="region" aria-label="Price controls">
      <label for="currency">Currency:</label>
      <select id="currency" aria-label="Select currency">
        <option value="GBP" selected>GBP £</option>
        <option value="EUR">EUR €</option>
        <option value="USD">USD $</option>
        <option value="JPY">JPY ¥</option>
        <option value="AUD">AUD $</option>
        <option value="CAD">CAD $</option>
        <option value="SGD">SGD $</option>
      </select>

      <label for="vatMode">Price mode:</label>
      <select id="vatMode" aria-label="Select VAT display mode">
        <option value="gross" selected>VAT-inclusive (recommended)</option>
        <option value="net">Ex-VAT (B2B)</option>
      </select>

      <input id="search" type="search" placeholder="Search SKU or name" aria-label="Search products">
      <span id="rateInfo" class="muted"></span>
    </div>
  </header>

  <main>
    <table id="priceTable" aria-label="Price list">
      <thead>
        <tr>
          <th>SKU</th>
          <th>Product</th>
          <th class="num">Price</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <details class="notes">
      <summary>Notes & Disclaimers</summary>
      <ul>
        <li>Prices are converted from GBP using the latest daily reference rate via Frankfurter (ECB). Rates typically update once per working day (~16:00 CET); indicative, not tradable quotes.</li>
        <li>An FX buffer may be applied (+2% by default) to cover spreads/fees.</li>
        <li>For UK consumer display, show VAT-inclusive totals where applicable.</li>
        <li>Prices may change without notice. Rate date/source are shown above.</li>
      </ul>
    </details>
  </main>

  <footer>
    <small>© <span id="year"></span> BC SoftWear. FX source: Frankfurter (ECB). VAT guidance: UK Trading Standards / HMRC.</small>
  </footer>

  <script>
    // === CONFIG ===
    const CSV_FILE   = 'price-list.csv'; // CSV must be in the same folder as index.html
    const VAT_RATE   = 0.20;             // UK standard VAT
    const FX_BUFFER  = 0.02;             // +2% buffer to cover spreads/fees
    const DECIMALS   = { GBP: 2, EUR: 2, USD: 2, AUD: 2, CAD: 2, SGD: 2, JPY: 0 };

    const currencySelect = document.getElementById('currency');
    const vatSelect      = document.getElementById('vatMode');
    const searchInput    = document.getElementById('search');
    const rateInfo       = document.getElementById('rateInfo');
    const tbody          = document.querySelector('#priceTable tbody');
    document.getElementById('year').textContent = new Date().getFullYear();

    let fxRates  = null;
    let products = [];

    // -------- CSV parser (robust to blank lines and quotes) --------
    function parseCSV(text) {
      const rows = [];
      let cur = [], val = '', inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i], n = text[i+1];
        if (c === '\ufeff') continue; // strip BOM
        if (c === '"') {
          if (inQuotes && n === '"') { val += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (c === ',' && !inQuotes) {
          cur.push(val); val = '';
        } else if ((c === '\n' || c === '\r') && !inQuotes) {
          // end of row
          if (val !== '' || cur.length) { cur.push(val); rows.push(cur); }
          cur = []; val = '';
          if (c === '\r' && n === '\n') i++;
        } else {
          val += c;
        }
      }
      if (val !== '' || cur.length) { cur.push(val); rows.push(cur); }
      // drop leading empty rows
      return rows.filter(r => r.some(cell => (cell || '').trim() !== ''));
    }

    function toNumber(x) {
      const t = String(x ?? '').trim();
      if (!t) return NaN;
      const n = Number(t.replace(/[^0-9.+-]/g, ''));
      return Number.isFinite(n) ? n : NaN;
    }

    function formatMoney(amount, ccy) {
      const decimals = DECIMALS[ccy] ?? 2;
      return new Intl.NumberFormat(undefined, {
        style: 'currency', currency: ccy,
        minimumFractionDigits: decimals, maximumFractionDigits: decimals
      }).format(amount);
    }

    // -------- find actual header row (handles leading blanks) --------
    function findHeaderIndex(rows) {
      for (let i = 0; i < rows.length; i++) {
        const hdr = rows[i].map(h => (h || '').trim());
        if (hdr.includes('SKU') && hdr.includes('Product Name')) return i;
      }
      return -1;
    }

    // choose a unit price per product line
    function pickUnitPrice(row, idx) {
      const p1 = toNumber(row[idx['Price 1']]);
      const p2 = toNumber(row[idx['Price 2']]);
      const p3 = toNumber(row[idx['Price 3']]);
      if (Number.isFinite(p1)) return p1;
      if (Number.isFinite(p2)) return p2;
      if (Number.isFinite(p3)) return p3;
      return NaN;
    }

    function buildProducts(rows) {
      const headerIndex = findHeaderIndex(rows);
      if (headerIndex < 0) throw new Error('Header row not found — expected columns: SKU, Product Name');

      const headers = rows[headerIndex].map(h => h.trim());
      const idx = {}; headers.forEach((h, i) => idx[h] = i);

      const required = ['Product Name', 'SKU', 'Price 1', 'Price 2', 'Price 3'];
      required.forEach(k => { if (idx[k] == null) console.warn('Missing column', k); });

      const map = new Map(); // sku -> { sku, name, gbpNet }
      for (let r = headerIndex + 1; r < rows.length; r++) {
        const row = rows[r];
        const sku  = (row[idx['SKU']] || '').trim();
        const name = (row[idx['Product Name']] || '').trim();
        if (!sku || !name) continue;

        const price = pickUnitPrice(row, idx);
        if (!Number.isFinite(price) || price <= 0) continue;

        if (!map.has(sku)) map.set(sku, { sku, name, gbpNet: price });
        else {
          const cur = map.get(sku);
          if (price < cur.gbpNet) cur.gbpNet = price;
        }
      }
      return Array.from(map.values());
    }

    // -------- FX: fetch, cache, and graceful fallback --------
    function cacheRates(ratesObj) {
      try { localStorage.setItem('fxRatesGBP', JSON.stringify({ ...ratesObj, cachedAt: new Date().toISOString() })); } catch {}
    }
    function getCachedRates() {
      try {
        const raw = localStorage.getItem('fxRatesGBP'); if (!raw) return null;
        const obj = JSON.parse(raw);
        const ageMs = Date.now() - new Date(obj.cachedAt).getTime();
        if (ageMs > 18 * 60 * 60 * 1000) return null; // 18h
        return obj;
      } catch { return null; }
    }
    async function loadRates() {
      const cached = getCachedRates();
      if (cached) { fxRates = cached; rateInfo.textContent = `FX base GBP · rate date ${fxRates.date}`; return; }
      const res = await fetch('https://api.frankfurter.dev/v1/latest?base=GBP');
      if (!res.ok) throw new Error('FX request failed ' + res.status);
      fxRates = await res.json();
      cacheRates(fxRates);
      rateInfo.textContent = `FX base GBP · rate date ${fxRates.date}`;
    }

    function computeDisplayPrice(gbpNet, currency, vatMode) {
      const rate = currency === 'GBP' ? 1 : fxRates?.rates?.[currency];
      if (!rate) throw new Error('Missing FX rate for ' + currency);
      const buffered = rate * (1 + FX_BUFFER);
      const netTarget = gbpNet * buffered;
      return vatMode === 'net' ? netTarget : netTarget * (1 + VAT_RATE);
    }

    function render() {
      const q        = (searchInput.value || '').trim().toLowerCase();
      const currency = currencySelect.value;
      const vatMode  = vatSelect.value;

      tbody.innerHTML = '';
      products
        .filter(p => !q || p.sku.toLowerCase().includes(q) || p.name.toLowerCase().includes(q))
        .forEach(p => {
          let amount;
          try { amount = computeDisplayPrice(p.gbpNet, currency, vatMode); } catch { amount = NaN; }
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${p.sku}</td>
            <td>${p.name}</td>
            <td class="num">${isNaN(amount) ? '-' : formatMoney(amount, currency)}</td>
          `;
          tbody.appendChild(tr);
        });
    }

    async function init() {
      try {
        // 1) Load CSV
        const csvRes  = await fetch(CSV_FILE);
        if (!csvRes.ok) throw new Error('Cannot load ' + CSV_FILE + ' (status ' + csvRes.status + ')');
        const csvText = await csvRes.text();
        const rows    = parseCSV(csvText);
        products      = buildProducts(rows);
        if (!products.length) throw new Error('CSV parsed but no products — check headers and price columns');

        // 2) Load FX (if fails, fall back to GBP only)
        try {
          await loadRates();
        } catch (fxErr) {
          console.warn('FX unavailable, falling back to GBP only:', fxErr);
          currencySelect.value = 'GBP';
          rateInfo.textContent = 'FX unavailable — showing GBP only';
        }

        render();
      } catch (e) {
        console.error(e);
        rateInfo.textContent = 'Problem loading CSV or FX — showing nothing';
        tbody.innerHTML = '<tr><td colspan="3" class="num">No data</td></tr>';
      }
    }

    currencySelect.addEventListener('change', render);
    vatSelect.addEventListener('change', render);
    searchInput.addEventListener('input', render);

    init();
  </script>
</body>
</html>
