
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BC SoftWear — Customer Price List</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Public multi-currency customer price list with VAT-inclusive display, daily FX conversion, and tiered pricing.">
  styles.css
  <!-- Robust CSV parser -->
  <script src="https://cdn.jsdelivr.nete@5.4.1/papaparse.min.js</script>
  <style>
    /* Tiered pricing visuals */
    .tiers { display: grid; gap: 6px; }
    .tier { display: flex; justify-content: space-between; align-items: baseline; }
    .tier .qty { color:#555; }
    .tier .amt { font-weight:600; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:.85rem; color:#333; background:#fafafa; }
  </style>
</head>
<body>
  <header>
    <h1>BC SoftWear — Customer Price List</h1>

    <div class="controls" role="region" aria-label="Price controls">
      <label for="currency">Currency:</label>
      <select id="currency" aria-label="Select currency">
        <option value="GBP" selected>GBP £</option>
        <option value="EUR">EUR €</option>
        <option value="USD">USD $</option>
        <option value="JPY">JPY ¥</option>
        <option value="AUD">AUD $</option>
        <option value="CAD">CAD $</option>
        <option value="SGD">SGD $</option>
      </select>

      <label for="vatMode">Price mode:</label>
      <select id="vatMode" aria-label="Select VAT display mode">
        <option value="gross" selected>VAT-inclusive (recommended)</option>
        <option value="net">Ex-VAT (B2B)</option>
      </select>

      <input id="search" type="search" placeholder="Search SKU or name" aria-label="Search products">
      <span id="rateInfo" class="muted"></span>
    </div>
  </header>

  <main>
    <table id="priceTable" aria-label="Price list">
      <thead>
        <tr>
          <th>SKU</th>
          <th>Product</th>
          <th class="num">Tiered Prices</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <details class="notes">
      <summary>Notes & Disclaimers</summary>
      <ul>
        <li>FX conversion uses the latest daily ECB reference rate (via Frankfurter). Rates update daily and are indicative, not tradable quotes.</li>
        <li>We apply a small FX buffer by default to cover card/FX spreads.</li>
        <li>For consumer display in the UK, VAT-inclusive totals should be shown when inviting purchase.</li>
      </ul>
    </details>
  </main>

  <footer>
    <small>© <span id="year"></span> BC SoftWear. FX source: Frankfurter (ECB). VAT guidance: UK Trading Standards / HMRC.</small>
  </footer>

  <script>
    // === CONFIG ===
    const CSV_FILE   = 'price-list.csv';      // CSV in same folder as index.html
    const VAT_RATE   = 0.20;                  // UK standard VAT
    const FX_BUFFER  = 0.02;                  // +2% buffer for spreads/fees
    const DECIMALS   = { GBP: 2, EUR: 2, USD: 2, AUD: 2, CAD: 2, SGD: 2, JPY: 0 };

    const currencySelect = document.getElementById('currency');
    const vatSelect      = document.getElementById('vatMode');
    const searchInput    = document.getElementById('search');
    const rateInfo       = document.getElementById('rateInfo');
    const tbody          = document.querySelector('#priceTable tbody');
    document.getElementById('year').textContent = new Date().getFullYear();

    let fxRates  = null;
    let products = [];

    // --- Helpers ---
    const norm = s => (String(s||'').toLowerCase().replace(/[^a-z0-9]/g,''));
    const money = (amount, ccy) => {
      const decimals = DECIMALS[ccy] ?? 2;
      return new Intl.NumberFormat(undefined, {
        style:'currency', currency: ccy, minimumFractionDigits:decimals, maximumFractionDigits:decimals
      }).format(amount);
    };
    const num = x => {
      const t = String(x ?? '').trim();
      if (!t) return NaN;
      const n = Number(t.replace(/[^0-9.+-]/g,''));
      return Number.isFinite(n) ? n : NaN;
    };

    // --- Build products with fuzzy header matching ---
    function buildProductsFromRows(rows) {
      if (!rows.length) return [];

      // Find header row (must have SKU & Product Name)
      let headerIdx = rows.findIndex(r => {
        const cols = Object.keys(r);
        return cols.some(c => norm(c)==='sku') && cols.some(c => norm(c)==='productname');
      });
      if (headerIdx === -1) headerIdx = 0;

      const hdrRow = rows[headerIdx];
      const cols = Object.keys(hdrRow);

      // Map needed columns (fuzzy match to tolerate spacing/UTF-8 quirks)
      const findCol = (...candidates) => {
        const targets = candidates.map(norm);
        const match = cols.find(c => targets.includes(norm(c)));
        return match ?? null;
      };

      const COL_SKU   = findCol('sku');
      const COL_NAME  = findCol('productname');
      const COL_Q1    = findCol('qtyband1','qtyband_1','qty1','qtybandone');
      const COL_P1    = findCol('price1','unitprice1');
      const COL_Q2    = findCol('qtyband2','qtyband_2','qty2','qtybandtwo');
      const COL_P2    = findCol('price2','unitprice2');
      const COL_Q3    = findCol('qtyband3','qtyband_3','qty3','qtybandthree');
      const COL_P3    = findCol('price3','unitprice3');

      if (!COL_SKU || !COL_NAME) {
        console.error('Missing SKU or Product Name columns.');
        return [];
      }

      const list = [];
      rows.forEach(r => {
        const sku  = (r[COL_SKU]  || '').trim();
        const name = (r[COL_NAME] || '').trim();
        if (!sku || !name) return;

        const tiers = [];
        const pairs = [
          { qty: num(r[COL_Q1]), price: num(r[COL_P1]) },
          { qty: num(r[COL_Q2]), price: num(r[COL_P2]) },
          { qty: num(r[COL_Q3]), price: num(r[COL_P3]) }
        ];
        pairs.forEach(p => {
          if (Number.isFinite(p.price)) tiers.push({ qty: Number.isFinite(p.qty) ? p.qty : null, gbpNet: p.price });
        });

        if (tiers.length) list.push({ sku, name, tiers });
      });

      return list;
    }

    // --- FX with cache & graceful fallback ---
    function cacheRates(ratesObj) {
      try { localStorage.setItem('fxRatesGBP', JSON.stringify({ ...ratesObj, cachedAt: new Date().toISOString() })); } catch {}
    }
    function getCachedRates() {
      try {
        const raw = localStorage.getItem('fxRatesGBP'); if (!raw) return null;
        const obj = JSON.parse(raw);
        const ageMs = Date.now() - new Date(obj.cachedAt).getTime();
        if (ageMs > 18*60*60*1000) return null; // 18h
        return obj;
      } catch { return null; }
    }
    async function loadRates() {
      const cached = getCachedRates();
      if (cached) { fxRates = cached; rateInfo.textContent = `FX base GBP · rate date ${fxRates.date}`; return; }
      const res = await fetch('https://api.frankfurter.dev/v1/latest?base=GBP');
      if (!res.ok) throw new Error('FX request failed ' + res.status);
      fxRates = await res.json();
      cacheRates(fxRates);
      rateInfo.textContent = `FX base GBP · rate date ${fxRates.date}`;
    }

    function convertTierAmount(gbpNet, currency, vatMode) {
      const rate = currency === 'GBP' ? 1 : fxRates?.rates?.[currency];
      if (!rate) throw new Error('Missing FX rate for ' + currency);
      const buffered = rate * (1 + FX_BUFFER);
      const netTarget = gbpNet * buffered;
      return vatMode === 'net' ? netTarget : netTarget * (1 + VAT_RATE);
    }

    function render() {
      const q        = (searchInput.value || '').trim().toLowerCase();
      const currency = currencySelect.value;
      const vatMode  = vatSelect.value;

      tbody.innerHTML = '';
      products
        .filter(p => !q || p.sku.toLowerCase().includes(q) || p.name.toLowerCase().includes(q))
        .forEach(p => {
          const tierHTML = p.tiers.map(t => {
            const amt = convertTierAmount(t.gbpNet, currency, vatMode);
            const qtyLabel = t.qty ? `${t.qty}+` : `Tier`;
            return `<div class="tier"><span class="qty pill">${qtyLabel}</span><span class="amt">${money(amt, currency)}</span></div>`;
          }).join('');

          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${p.sku}</td>
            <td>${p.name}</td>
            <td class="num"><div class="tiers">${tierHTML}</div></td>
          `;
          tbody.appendChild(tr);
        });
    }

    async function init() {
      try {
        // 1) Load CSV via Papa Parse (header-aware, UTF-8 tolerant)
        const resp = await fetch(CSV_FILE);
        if (!resp.ok) throw new Error('Cannot load ' + CSV_FILE + ' (status ' + resp.status + ')');
        const csvText = await resp.text();

        const parsed = Papa.parse(csvText, {
          header: true,             // read header names
          skipEmptyLines: true,     // ignore empty lines
          transformHeader: h => h.trim(), // trim headers
        });
        if (parsed.errors?.length) console.warn('CSV parse warnings:', parsed.errors);
        const rows = parsed.data;   // array of objects

        products = buildProductsFromRows(rows);
        if (!products.length) throw new Error('CSV parsed but no products with tier prices found — check headers and F→K columns.');

        // 2) Load FX (fall back to GBP if FX fails)
        try { await loadRates(); }
        catch (fxErr) {
          console.warn('FX unavailable, falling back to GBP only:', fxErr);
          currencySelect.value = 'GBP';
          rateInfo.textContent = 'FX unavailable — showing GBP only';
        }

        render();
      } catch (e) {
        console.error(e);
        rateInfo.textContent = 'Problem loading CSV or FX — showing nothing';
        tbody.innerHTML = '<tr><td colspan="3" class="num">No data</td></tr>';
      }
    }

    currencySelect.addEventListener('change', render);
    vatSelect.addEventListener('change', render);
    searchInput.addEventListener('input', render);

    init();
  </script>
</body>
</html>
